----------------Prevent Circular Reference Errors in Json-----------------------------------------

In this configuration, the ASP.NET Core application is set up to use **Newtonsoft.Json** instead of the default `System.Text.Json` serializer. 
This is done by adding the following line in the `Program.cs` file:

\\\csharp
builder.Services.AddControllers()
    .AddNewtonsoftJson(options =>
    {
        options.SerializerSettings.ReferenceLoopHandling = ReferenceLoopHandling.Ignore;
    });
----

This setup serves two main purposes:

1. **Enable Newtonsoft.Json Integration:**
   By calling `.AddNewtonsoftJson()`, the application switches its JSON handling engine from `System.Text.Json` to `Newtonsoft.Json`.
This is useful when you need advanced serialization features like custom converters, flexible property naming, or compatibility with older code that uses Newtonsoft attributes such as `[JsonProperty]`, `[JsonIgnore]`, or `[JsonConverter]`.

2. **Prevent Circular Reference Errors:**
   The line `options.SerializerSettings.ReferenceLoopHandling = ReferenceLoopHandling.Ignore;` solves one of the most common issues in APIs ‚Äî circular reference loops.
   For example, when working with Entity Framework models that have bidirectional relationships (like `Parent ‚Üí Child ‚Üí Parent`), JSON serialization can enter an infinite loop and cause runtime errors.
   By setting `ReferenceLoopHandling` to `Ignore`, Newtonsoft.Json simply skips over repeated references, ensuring smooth and safe serialization without breaking your API responses.

In short, this configuration improves API stability and flexibility by using a robust JSON serializer and eliminating circular reference serialization issues often encountered in complex object graphs.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------Data Validation and ModelState----------------------------------------------
In **ASP.NET Core**, model validation is not automatically enforced unless you enable it through the `[ApiController]` attribute. Here‚Äôs how it works:

---

### üß© How Model Validation Works
When an HTTP request reaches your controller:

1. ASP.NET Core automatically performs **model binding** and **data annotation validation** (e.g., `[Required]`, `[Range]`, `[MaxLength]`).
2. The results of that validation are stored in the `ModelState` object.
3. It‚Äôs your responsibility to decide whether to proceed or stop execution based on `ModelState.IsValid`.

Example:
```csharp
[HttpPost]
public IActionResult CreateUser(UserDto model)
{
    if (!ModelState.IsValid)
        return BadRequest(ModelState);

    _dbContext.Users.Add(_mapper.Map<User>(model));
    _dbContext.SaveChanges();
    return Ok();
}
```
If you skip this check, invalid data can reach your database and cause runtime or integrity issues.
---
### ‚öôÔ∏è Automatic Validation with `[ApiController]`
When you decorate your controller with the `[ApiController]` attribute, ASP.NET Core automatically validates incoming models for you.

```csharp
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    [HttpPost]
    public IActionResult Create(UserDto model)
    {
        // No need to check ModelState manually
        // Invalid models automatically return 400 Bad Request
        return Ok();
    }
}
```
In this mode:
* The framework automatically returns a **400 Bad Request** if the model is invalid.
* The response includes a `ProblemDetails` object describing validation errors.
* You don‚Äôt need to write `if (!ModelState.IsValid)`.

---
### ‚úÖ Summary

| Controller Type           | Automatic Model Validation     | Manual Check Required                      |
| ------------------------- | ------------------------------ | ------------------------------------------ |
| With `[ApiController]`    | ‚úÖ Yes (automatic 400 response) | ‚ùå Not required                             |
| Without `[ApiController]` | ‚ùå No                           | ‚úÖ Must check `ModelState.IsValid` manually |

---
**In short:**
* ASP.NET Core *always* performs validation,
* But *only* `[ApiController]` automatically stops execution when validation fails.
* Otherwise, you must manually check `ModelState.IsValid` before proceeding.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------Sending Objects in Query String vs Request Body in ASP.NET Core---------------------------------------------------

### üß© Sending Objects in Query String vs Request Body in ASP.NET Core
ASP.NET Core allows you to send data to your API through either the **query string** or the **request body**. Both approaches have their use cases, advantages, and limitations ‚Äî understanding these helps you design more efficient and secure endpoints.
--

### üîπ 1. Sending Objects in Query String
When using the query string, ASP.NET Core‚Äôs **model binder** automatically maps URL parameters to object properties.
#### Example URL
```
GET /api/users?Name=Ali&Age=30&IsActive=true
```

#### Model
```csharp
public class UserFilterDto
{
    public string Name { get; set; }
    public int Age { get; set; }
    public bool IsActive { get; set; }
}
```

#### Controller
```csharp
[HttpGet]
public IActionResult GetUsers([FromQuery] UserFilterDto filter)
{
    return Ok(filter);
}
```

ASP.NET Core:
* Parses the query string into key/value pairs.
* Matches keys with object property names (case-insensitive).
* Converts string values to the correct data types.
* Supports nested properties (e.g. `Customer.Name=Ali`).
---

### ‚úÖ Pros of Using `[FromQuery]`
* **Simple and convenient** for small sets of filter parameters.
* **Automatic binding** ‚Äî no manual parsing required.
* **Ideal for GET requests**, where data retrieval is the goal.
* **Easily testable** via browser or tools like Postman (parameters visible in URL).
* **Fast binding** since the payload is small.

### ‚ö†Ô∏è Cons of `[FromQuery]`
* **Limited size** ‚Äî most browsers and servers restrict URLs to about **2,000 characters**.
* **No JSON structure support** ‚Äî only key-value pairs.
* **Less secure** ‚Äî values appear in logs, history, and browser address bars.
* **Hard to manage** for complex or nested data.
* **GET requests only** ‚Äî using it for data modification breaks REST conventions.
---

### üîπ 2. Sending Objects in Request Body
When using the request body, you send the object as **JSON** (or another supported format), and ASP.NET Core deserializes it into your model.

#### Example
```csharp
[HttpPost]
public IActionResult SearchUsers([FromBody] UserFilterDto filter)
{
    return Ok(filter);
}
```

#### Example JSON Request
```json
{
  "name": "Ali",
  "age": 30,
  "isActive": true
}
```

### ‚úÖ Pros of Using `[FromBody]`
* **Supports full JSON payloads** ‚Äî ideal for complex, nested, or structured data.
* **No length limitation** ‚Äî handles large payloads easily.
* **More secure** ‚Äî data isn‚Äôt visible in the URL or browser logs.
* **Easier to maintain** as objects grow in complexity.
* **Consistent structure** ‚Äî matches client-side JSON models directly.

### ‚ö†Ô∏è Cons of `[FromBody]`
* **Cannot be used with GET requests** (HTTP spec prohibits bodies in GET).
* **Slightly higher overhead** due to serialization/deserialization.
* **Not directly visible** in the browser address bar (less convenient for quick manual testing).
* **One `[FromBody]` parameter allowed per action** ‚Äî others must come from route or query.
---

### ‚öñÔ∏è 3. Comparison Summary
| Feature / Aspect                | `[FromQuery]`                    | `[FromBody]`                               |
| ------------------------------- | -------------------------------- | ------------------------------------------ |
| **Typical HTTP verbs**          | GET, DELETE                      | POST, PUT, PATCH                           |
| **Data format**                 | Key-value pairs                  | JSON (or XML, etc.)                        |
| **Complex/nested data**         | ‚ùå Limited                        | ‚úÖ Fully supported                          |
| **URL visibility**              | üîì Visible in URL                | üîí Hidden in body                          |
| **Security for sensitive data** | ‚ö†Ô∏è Risky                         | ‚úÖ Safer                                    |
| **Size limit**                  | ~2KB (depends on server/browser) | Practically unlimited                      |
| **Performance**                 | ‚ö° Faster for small payloads      | üß† Better for structured or large payloads |
| **Ease of testing**             | ‚úÖ Quick via browser              | ‚ö†Ô∏è Requires tool like Postman              |
| **REST convention alignment**   | ‚úÖ Ideal for GET/read             | ‚úÖ Ideal for create/search/update           |
---

### üß† Best Practice
* Use **`[FromQuery]`** for **simple filters, search parameters, pagination, and sorting** in GET requests.
* Use **`[FromBody]`** for **complex filtering, large data objects, or sensitive inputs** with POST/PUT methods.
* Avoid mixing large JSON in query strings ‚Äî it‚Äôs unreadable, error-prone, and may exceed URL limits.

---
**In short:**
ASP.NET Core automatically binds data from both query strings and request bodies, but their purposes differ.
Use **query strings for light, readable filters**, and **request bodies for complex or sensitive payloads** ‚Äî this keeps your API efficient, secure, and well-structured.

